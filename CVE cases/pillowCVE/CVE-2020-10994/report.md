# CVE-2020-10944
Pillow

out-of-bounds reads via a crafted JP2 file in libImaging/Jpeg2KDecode.c

Patched Code
```C
// add bound check in the source code
static void
j2ku_gray_l(opj_image_t *in, const JPEG2KTILEINFO *tileinfo,
            const UINT8 *tiledata, Imaging im)
{
    /* csiz*h*w + offset = tileinfo.datasize */
    size_t buffer_size = 0, tile_bytes = 0;
    unsigned n, tile_height, tile_width;
    int components;
    /* Check the tile bounds; if the tile is outside the image area, or if it has a negative width or height (i.e. the coordinates are swapped), bail. */
    if (tile_info.x0 >= tile_info.x1
        || tile_info.y0 >= tile_info.y1
        || tile_info.x0 < image->x0
        || tile_info.y0 < image->y0
        || tile_info.x1 - image->x0 > im->xsize
        || tile_info.y1 - image->y0 > im->ysize) {
        state->errcode = IMAGING_CODEC_BROKEN;
        state->state = J2K_STATE_FAILED;
        goto quick_exit;
    }
    /* Sometimes the tile_info.datasize we get back from openjpeg is is less than numcomps*w*h, and we overflow in the shuffle stage */

    tile_width = tile_info.x1 - tile_info.x0;
    tile_height = tile_info.y1 - tile_info.y0;
    components = tile_info.nb_comps == 3 ? 4 : tile_info.nb_comps;
    if (( tile_width > UINT_MAX / components ) ||
            ( tile_height > UINT_MAX / components ) ||
            ( tile_width > UINT_MAX / (tile_height * components )) ||
            ( tile_height > UINT_MAX / (tile_width * components ))) 
    {
        state->errcode = IMAGING_CODEC_BROKEN;
        state->state = J2K_STATE_FAILED;
        goto quick_exit;
    }
    tile_bytes = tile_width * tile_height * components;
    if (tile_bytes > tile_info.data_size) {
        tile_info.data_size = tile_bytes;
    }
}
```