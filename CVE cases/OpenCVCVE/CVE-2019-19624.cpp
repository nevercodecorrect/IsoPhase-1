#include <iostream>
#include <opencv2/opencv.hpp>
#include <opencv2/video/tracking.hpp>

using namespace cv;
using namespace std;

//create method for creation
cv::Ptr<cv::DISOpticalFlow> createflow(){
	printf("\n === createflow() ===\n");
	cv::Ptr<cv::DISOpticalFlow> ret = cv::DISOpticalFlow::create();
	printf(" === end of createflow() ===\n\n");
	return ret;
}

cv::Mat createMat(const int mat_size){
	printf(" === createMat(): creating Mat of size %d ===\n", mat_size);
	Mat ret = Mat(mat_size, mat_size, CV_8UC1, 42);
	printf(" === end of createMat() ===\n");
	return ret;
}

void calcflow(Ptr<DISOpticalFlow> of, Mat m1, Mat m2, Mat m3){
	printf("\n === calcflow() ===\n");
	of->calc(m1, m2, m3);
	printf(" === end of calcflow() ===\n\n");
}

int main(){
	cv::Ptr<cv::DISOpticalFlow> of = createflow();	

	const int mat_size = 91; // use mat_size<=90 to crash and <= 11 to get coarsest_level<0
    	const int patch_size = 8;
    	int dis_coarsest_scale = (int)(std::log(mat_size / (4.0 * patch_size)) / std::log(2.0) + 0.5); /* Original code serach for maximal movement of width/4 */
    	std::cout << "Coarsest scale " << dis_coarsest_scale << ", finest scale " << of->getFinestScale() << std::endl;

	// vulnerability intruduced here
    	cv::Mat x = createMat(mat_size);
    	cv::Mat y = createMat(mat_size);
    	cv::Mat flow;

	calcflow(of, x, y, flow);

    	std::cout << "Result size " << flow.rows << ", " << flow.cols << std::endl;
	return 0;	


}
